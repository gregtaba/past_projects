Η εργασια αυτη γραφτηκε απο τον Γρηγορη Ταμπαξη.
ΑΜ:1115202000188

Η εργασια τρεχει μεσω 2 βασικων αρχειων JobCommander και jobExecutorServer.Αρχικα θα αναλυσουμε τον jobCommander.

Οταν καλείται ο jobCommander αρχικα θα ελεγξει αν υπαρχει το αρχειο jobExecutorServer.txt στο ιδιο directory .Αν δεν υπαρχει τοτε με χρηση fork exec θα τρεξει 
εκεινος το προγραμμα ./jobExecutorServer ωστε να ξεκινησει ο σερβερ.Αν το txt αρχειο υπαρχει ηδη τοτε προχωραμε παρακατω.

Στην συνεχεια αποθηκευει το pid του jobExecutorServer καθως θα το χρειαστει για να μπορει να στελνει σηματα στον jobExecutorServer.

Μετα στελνει ενα signal στον jobExecutorServer για να τον ειδοποιησει οτι θα του στειλει μηνυμα μεσω pipe το οποιο συμβαινει ακριβως μετα.

Στην συνεχεια μεσω if statement θα εντοπισει τι ειδους δραστηριοτητας πραγματοποιει αναλογα με το δευτερο και τριτο ορισμα του προγραμματος.
Δηλαδη ειτε issueJob,exit,setConcurrency,poll running,poll queued.

Στις διαδικασιες issueJob,poll running,poll queued ουσιαστικα απλα διαβαζει το pipe στο οποιο γραφει ο jobExecutorServer ,στελνει σημα οτι διαβασε το pipe 
και τελος εκτυπωνει το μηνυμα που διαβασε απο το pipe.

Στην διαδικασια exit το ακριβως ιδιο με τα παραπανω μονο που τελιωνει το προγραμμα μεσα στο if statement.

Τελος στην διαδικασια setConcurrency δεν κανει κατι αφου δεν του επιστρεφει κατι ο jobExecutorServer.

Μολις φυγει απο το if statement θα στειλει ενα signal στον jobExecutorServer με το οποιο ουσιαστικα τον ειδοποιει οτι ο σκοπος του τελειωσε.Μετα απο αυτο ο 
jobCommander τερματιζει και ο jobExecutorServer επιστρέφει στην αρχή του loop του.

Ο τροπος με τον οποιο ο jobcommander αποστελλει τα σηματα επιτρεπει την δυνατοτητα να σταλθουν
5 διαφορετικα σηματα με διαφορα 0,1 δευτερολεπτου το καθενα.Αυτο συμβαινει για να διευκολυνει τον εκσυγχρονισμο των δυο προγραμματων καθως αν το πρωτο 
σημα για καποιο λογο δεν καταφερει να σταλθει τοτε στελνεται το δευτερο και παει λεγοντας.Ειναι ενας τροπος να σιγουρευτουμε οτι το σημα θα φτασει στον 
jobExecutorServer και επομενως δεν θα κολλησει το προγραμμα.

Στην συνεχεια θα αναλυσουμε τον JobEexecutorServer.

Αρχικα δημιουργει τους signal handlers για τα σηματα SIGCHLD και SIGUSR2.

Επειτα μπαινουμε σε ενα συνεχομενο loop το οποιο θα συνεχιστει μεχρι να τερματιστει ο server μεσω της εντολης exit.

Στην αρχη του loop ελεγχει την δημιουργια του txt αρχειου .Αν το αρχειο δεν υπαρχει τοτε το δημιουργει.

Στην συνεχεια διαβαζει το pipe οπου γραφει ο commander για να παρει την εντολη που του εχει στειλει ο jobCommander. 

Στην συνεχεια θα τρεξει τις εξης συναρτησεις 

poll_queued()  (εμφανιση ολων των εντολων που βρισκονται σε αναμονη εκεινη την στιγμη)
 
poll_running() (εμφανιση ολων των εντολων που εκτελουνται εκεινη την στιγμη)

set_concurrency() (αλλαγη του concurrency)
        
exit_command() (κλεισιμο του jobExecutorServer)
        
Stop() (αφαιρεση καποιου command ειτε σε εκτελεση ειτε σε αναμονη)



καθε μια απο εκεινες τις συναρτησεις ελεγχει την εντολη που εχει λαβει απο τον jobCommander και αναλογως με το αποτελεσμα της αναζητησης πραγματοποιει η οχι καποια 
δραστηριοτητα.Τι ειδους δραστηριοτητα γραφεται διπλα απο τις συναρτησεις.Τελος τρεχει μια συναρτηση που εχει διπλο ρολο.

issueJob()(αναγνωριση της εντολης που εχει λαβει ο jobExecutorServer απο τον jobCommander και αποθηκευση στην ουρα αναμονης και στην συνεχεια ελεγχος για αφαιρεση 
εντολων απο ουρα αναμονης και τοποθετησης τους στην δομη για ενεργες εντολες.)

Η συναρτηση issueJob στο πρωτο κομματι της απλα ανγνωριζει την εντολη που εχει λαβει ο jobExecutorServer απο τον jobCommander και την αποθηκευει στην ουρα αναμονης.
Στο δευτερο κομματι της ελεγχει αν υπαρχουν διαθσειμες θεσεις ωστε να ξεκινησουν εντολες απο την ουρα αναμονης.Αν υπαρχουν τοτε ξεκιναει την διαδικασια του να σβησει
 εκεινες τις εντολες απο την ουρα αναμονης και να τις τοποθετησει στη δομη για τις ενεργες εντολες.

Τελος περιμενει να λαβει σημα απο τον commander ωστε να ξαναξεκινησει το  loop απο την αρχη .Οσο περιμενει αυτο το σημα επισης περιμενει για το σημα sigCHLD .Αν το 
λαβει τοτε τρεχει αμεσα την συναρτηση active_deQueue() η οποια ψαχνει την δομη των ενεργων εντολων και ειτε λογω stop() ειτε λογω φυσικου τερματισμου διαγραφει 
εντολες απο την δομη.


Το makefile που βρισκεται μαζι με τον κωδικα ουσιαστικα επιτυγχανει τα εξης:
μεταγλωτιση jobCompiler.c
μεταγλωτιση jobExecutorServer.c μαζι με function.c 
εκτελεση εντολης chmod +x allJobsStop.sh
εκτελεση εντολης chmod +x multijob.sh

Αρα μετα την εντολη make δεν χρειαζεται αλλη μεταγλωτιση σε αυτα τα αρχεια.

Οσο αφορα τις συναρτησεις που χρησιμοποιουνται στο προγραμμα για λεπτομερη περιγραφη υπαρχουν τα σχολια μεσα στον κωδικα.

Οσο αφορά θεματα μεταγλωτισης αλλων προγραμματων οπως πχ το progDelay.c με τον τροπο που εχω δημιουργησει το προγραμμα αν μεταγλωτισουμε το progDelay.c σε εκτελεσιμο
progDelay θα τρεξει μονο αν γραφτει ./progDelay <argument1> <argument2> .......

Αν γραφτει progDelay <argument1> <argument2> ....... τοτε το προγραμμα δεν θα τρεξει.Το ιδιο ισχυει αν θελουμε πχ να γραψουμε issuejob progDelay 2 
(αυτο δεν θα λειτουργησει),αυτο που πρεπει να γραψουμε ειναι issueJob ./progDelay 2

Επισης το progDelay δεν μεταγλωτιζεται απο το makefile που εχω δημιουργησει οποτε σε περιπτωση που θα χρησιμοποιηθει πρεπει να μεταγλωτιστει ξεχωριστα.

Oσο αφορα το θεμα πολλαπλων εντολων σε μια γραμμη οπως πχ η εντολη issueJob poll running το προγραμμα εχει φτιαχτει ετσι ωστε η εντολη να προχωραει 
σε υλοποιηση μονο αν το πρωτο γραμμα του string που εχουμε να ειναι ιδιο με το πρωτο γραμμα του προκαθορισμενου string στην συγκεκριμενη συναρτηση και 
ταυτοχρονα ολο το προκαθορισμενο string της συναρτησης να βρισκεται μεσα στο string που ελεγχεται.Αν δεν ισχυουν και τα 2 τοτε δεν τρεχεται η εντολη.

Τελος θα ηθελα να αναφερω μια αποφαση μου.Παροτι το queue position ειναι μεταβλητο και αλλαζει αναλογα την θεση του στοιχειου στην ουρα ,η τριπλετα ομως που περιεχει το queue position επειδη θεωρειται μοναδικο αναγνωριστικο στοιχειο 
υπεθεσα οτι δεν πρεπει να αλλαζει.Για αυτο τον λογο παροτι αλλαζουν τα queue position των εντολων που μπαινουν στο προγραμμα ,οι τριπλετες τους παραμενουν παντα σταθερες.














